var _extends=Object.assign||function(a){for(var d,b=1;b<arguments.length;b++)for(var e in d=arguments[b],d)Object.prototype.hasOwnProperty.call(d,e)&&(a[e]=d[e]);return a};const isDiagonal=(a,b)=>a.i!==b.i&&a.j!==b.j,search=({i:a,j:b},d)=>d.find(({pos:{i:e,j:k}})=>e===a&&k===b),heuristic=(a,b,d)=>{return"DIAGONAL"===d?Math.max(Math.abs(a.i-b.i),Math.abs(a.j-b.j)):"EUCLIDEAN"===d?Math.pow(a.i-b.i,2)+Math.pow(a.j-b.j,2):Math.abs(a.i-b.i)+Math.abs(a.j-b.j)},getDistance=(a,b)=>isDiagonal(a.pos,b.pos)?14:10,isGoal=({i:a,j:b},d)=>a===d.i&&b===d.j;class GraphController{constructor(a,b,d,e=0){this.type=e,this.graph=a,this.maxRow=b,this.maxCol=d}getAdjacent(a,b=!1){if(0===this.type)return this.getAdjacentOne(a,b)}getAdjacentOne(a,b=!1){let{pos:d}=a,e=[{i:d.i+1,j:d.j},{i:d.i,j:d.j+1},{i:d.i-1,j:d.j},{i:d.i,j:d.j-1}];return b&&e.push(...[{i:d.i+1,j:d.j-1},{i:d.i+1,j:d.j+1},{i:d.i-1,j:d.j+1},{i:d.i-1,j:d.j-1}]),e.filter(k=>0<=k.i&&k.i<this.maxRow&&0<=k.j&&k.j<this.maxCol).map(k=>this.at(k)).filter(k=>"BLOCK"!==k.color)}at(a){if(0===this.type){let{i:b,j:d}=a;if(a=b*this.maxCol+d,a>=this.graph.length)throw new TypeError(`No Node Found of ${b},${d}`);return this.graph[a]}return this.graph.nodes[a]}getPos({i:a,j:b}){return a*this.maxCol+b}}class BreadthFirstSearch{constructor(a,b,d,e=0){this._graph=new GraphController(a,b,d,e)}search(a,b,d=!1){let e=this._graph.at(a);const k=this._graph.getPos.bind(this._graph);let l=[];e.color="VISITED",e.predecessor=void 0,e.d=0;let m,n=[e];for(;0!==n.length;){let o=n.shift();if(o.pos.i===b.i&&o.pos.j===b.j){m=o;break}for(let p of this._graph.getAdjacent(o,d))"UNVISITED"===p.color&&(p.color="VISITED",p.predecessor=o,p.d=o.d+10,l.push({pos:k(p.pos),color:"VISITED",text:[{text:k(o.pos),offsetX:0,offsetY:2},{text:p.d,offsetX:0,offsetY:10}]}),n.push(p));o.color="EXPLORED",l.push({pos:k(o.pos),color:"EXPLORED"})}if(m){let o=`M ${m.x+5},${m.y+5}`,p=m.predecessor;for(o+=`L ${p.x+5},${p.y+5}`,console.log(b);p.predecessor;)p.color="VISITED",l.push({pos:k(p.pos),color:"PATH"}),p=p.predecessor,o+=` L ${p.x+5},${p.y+5}`;l.push({path:o})}return l}}class DepthFirstSearch{constructor(a,b,d,e=0){this._graph=new GraphController(a,b,d,e)}search(a,b,d=!1){this.diagonal=d,this.goal=b,this.action=[],this.time=0,this.getPos=this._graph.getPos.bind(this._graph);let e=this._graph.at(a);if(e.predecessor=void 0,this.final=void 0,this.dfs(e),this.final){let k=`M ${this.final.x+5},${this.final.y+5}`,l=this.final.predecessor;for(k+=`L ${l.x+5},${l.y+5}`;l.predecessor;)l.color="PATH",this.action.push({pos:this.getPos(l.pos),color:"PATH"}),l=l.predecessor,k+=` L ${l.x+5},${l.y+5}`;this.action.push({path:k})}return this.action}dfs(a){if(this.time++,a.d=this.time,a.color="VISITED",this.action.push({pos:this.getPos(a.pos),color:"VISITED",text:[{text:a.d,offsetX:0,offsetY:2}]}),a.pos.i===this.goal.i&&a.pos.j===this.goal.j)return void(this.final=a);for(let b of this._graph.getAdjacent(a,this.diagonal)){if(this.final)return;"UNVISITED"===b.color&&(b.predecessor=a,this.dfs(b))}a.color="EXPLORED",this.time++,a.f=this.time,this.action.push({pos:this.getPos(a.pos),color:"EXPLORED",text:[{text:a.d,offsetX:0,offsetY:2},{text:a.f,offsetX:0,offsetY:10}]}),this.final}}class Dijkstras{constructor(a,b,d,e=0){this._graph=new GraphController(a,b,d,e)}search(a,b,d=!1){this._graph.graph.forEach(p=>{p.d=Infinity,p.predecessor=null});const e=this._graph.getPos.bind(this._graph);let k=this._graph.at(a);k.d=0;let l=[];const m=[...this._graph.graph].filter(p=>"BLOCK"!==p.color),n=[];let o;for(;m.length!==n.length;){let p=this._graph.graph.reduce((r,t)=>{return t.d<r.d&&!t.visit?t:r},{d:Infinity});if(!p.pos)break;if(p.pos.i===b.i&&p.pos.j===b.j){o=p;break}p.visit=!0,n.push(m[e(p.pos)]),l.push({pos:e(p.pos),color:"EXPLORED"});for(let r of this._graph.getAdjacent(p,d)){const t=p.d+getDistance(p,r);if(r.d>t&&(r.d=t,r.predecessor=p,l.push({pos:e(r.pos),color:"VISITED",text:[{text:e(p.pos),offsetX:0,offsetY:2},{text:r.d,offsetX:0,offsetY:10}]})),o)break}}if(o){let p=`M ${o.x+5},${o.y+5}`,r=o.predecessor;for(p+=`L ${r.x+5},${r.y+5}`;r.predecessor;)r.color="VISITED",l.push({pos:e(r.pos),color:"PATH"}),r=r.predecessor,p+=` L ${r.x+5},${r.y+5}`;l.push({path:p})}return l}}class AStar{constructor(a,b,d,e=0){this._graph=new GraphController(a,b,d,e)}search(a,b,d=!1){const e=this._graph.getPos.bind(this._graph);let k=this._graph.at(a),l=[],m=[{pos:k.pos,f:0,g:0}],n=[],o,p=[];for(;m.length;){let r=m.reduce((w,z,A)=>{return z.f<w.f?_extends({},z,{i:A}):w},{f:Infinity,i:-1});if(-1===r.i)break;if(isGoal(r.pos,b)){o=r;break}p.push({pos:e(r.pos),color:"EXPLORED"}),m.splice(r.i,1);for(let w of this._graph.getAdjacent(r,d)){const z=10*heuristic(w.pos,b),A=getDistance(r,w)+r.g,B=z+A,C=n[e(w.pos)];if(!C||C&&C.f>B){const D=l[e(w.pos)];(!D||D&&D.f>B)&&(m.push({pos:w.pos,f:B,g:A,predecessor:r}),l[e(w.pos)]={pos:w.pos,f:B,g:A,predecessor:r},p.push({pos:e(w.pos),color:"VISITED",text:[{text:B,offsetX:0,offsetY:2},{text:z,offsetX:0,offsetY:10},{text:A,offsetX:6,offsetY:10}]}))}}if(o)break;n[e(r.pos)]=r}if(o){let r=this._graph.at(o.pos),t=`M ${r.x+5},${r.y+5}`,w=o.predecessor,z=this._graph.at(w.pos);for(t+=`L ${z.x+5},${z.y+5}`;w.predecessor;)w.color="VISITED",p.push({pos:e(w.pos),color:"PATH"}),w=w.predecessor,z=this._graph.at(w.pos),t+=` L ${z.x+5},${z.y+5}`;p.push({path:t})}return p}}self.onmessage=({data:[a,{graph:n,col:o,row:p},[d,e],[k,l],b,m=0]})=>{n.length||self.postMessage([]);let r="dfs"===a?new DepthFirstSearch(n,p,o,m):"a-star"===a?new AStar(n,p,o,m):"dijkstras"===a?new Dijkstras(n,p,o,m):new BreadthFirstSearch(n,p,o,m);console.log(a),self.postMessage(r.search({i:d,j:e},{i:k,j:l},b))};
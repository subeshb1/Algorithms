var _extends=Object.assign||function(c){for(var e,d=1;d<arguments.length;d++)for(var j in e=arguments[d],e)Object.prototype.hasOwnProperty.call(e,j)&&(c[j]=e[j]);return c};class GraphController{constructor(c){this.graph=c}getDistance(c,d){return c=this.at(c),d=this.at(d),parseInt(Math.pow(Math.pow(c.x-d.x,2)+Math.pow(c.y-d.y,2),0.5),10)}getAdjacent(c,d=0,e=0){let j=[];for(let k in this.graph.arc){const l=this.graph.arc[k];l.from===c.key?j.push([this.at(l.to),{value:e?this.getDistance(c.key,l.to):l.value,through:l.key}]):l.to===c.key&&0===d&&j.push([this.at(l.from),{value:e?this.getDistance(c.key,l.from):l.value,through:l.key}])}return j.sort((k,l)=>k[0].x>=l[0].x)}at(c){return this.graph.node[c]}}class BreadthFirstSearch{constructor(c){this._graph=new GraphController(c)}search(c,d,e,j=0){let k=this._graph.at(c),l=[];k.color="VISITED",k.predecessor=void 0,k.d=0,l.push({key:k.key,color:"VISITED",text:[{text:k.key,offsetX:0,offsetY:2},{text:k.d,offsetX:0,offsetY:10}]});let m,n=[k];for(;0!==n.length;){let o=n.shift();if(o.key===d){m=o;break}for(let p of this._graph.getAdjacent(o,j)){const{through:r}=p[1];p=p[0],"UNVISITED"===p.color&&(p.color="VISITED",p.predecessor=o,p.through=r,p.d=o.d+10,l.push({key:p.key,color:"VISITED",text:[{text:p.key,offsetX:0,offsetY:2},{text:p.d,offsetX:0,offsetY:10}]}),n.push(p))}o.color="EXPLORED",l.push({key:o.key,color:"EXPLORED"})}if(m)for(let o=m;o;)l.push({key:o.key,color:"PATH"}),o.through&&l.push({key:o.through,color:"PATH",type:"ARC"}),o=o.predecessor;return l}}class DepthFirstSearch{constructor(c){this._graph=new GraphController(c)}search(c,d,e,j=0){this.mode=j,this.goal=d,this.action=[];let k=this._graph.at(c);if(k.predecessor=void 0,this.final=void 0,this.dfs(k),this.final)for(let l=this.final;l;)this.action.push({key:l.key,color:"PATH"}),l.through&&this.action.push({key:l.through,color:"PATH",type:"ARC"}),l=l.predecessor;return this.action}dfs(c){if(this.time++,c.d=this.time,c.key===this.goal)return this.final=c,void this.action.push({key:c.key,color:"EXPLORED",text:[{text:c.d,offsetX:0,offsetY:2}]});c.color="VISITED",this.action.push({key:c.key,color:"VISITED",text:[{text:c.d,offsetX:0,offsetY:2}]});for(let d of this._graph.getAdjacent(c,this.mode)){const{through:e}=d[1];if(d=d[0],this.final)return;"UNVISITED"===d.color&&(d.predecessor=c,d.through=e,this.dfs(d))}this.final||(c.color="EXPLORED",this.time++,c.f=this.time,this.action.push({key:c.key,color:"EXPLORED",text:[{text:c.d,offsetX:0,offsetY:2},{text:c.f,offsetX:0,offsetY:10}]}))}}class Dijkstras{constructor(c){this._graph=new GraphController(c)}search(c,d,e,j=0){this._graph.getDistance.bind(this._graph);Object.keys(this._graph.graph.node).forEach(r=>{this._graph.graph.node[r].d=Infinity,this._graph.graph.node[r].predecessor=null});let l=this._graph.at(c);l.d=0;let m=[];const n=_extends({},this._graph.graph.node),o=[];let p;for(;Object.keys(n).length!==o.length;){let r=Object.keys(n).reduce((t,w)=>{return n[w].d<t.d&&!n[w].visit?n[w]:t},{d:Infinity});if(r.key===void 0)break;if(r.key===d){p=r;break}r.visit=!0,o.push(r),m.push({key:r.key,color:"EXPLORED"});for(let t of this._graph.getAdjacent(r,j,e)){const{through:w,value:y}=t[1],z=r.d+y;t=t[0],t.d>z&&(t.d=z,t.predecessor=r,t.through=w,m.push({key:t.key,color:"VISITED",text:[{text:r.key,offsetX:0,offsetY:2},{text:t.d,offsetX:0,offsetY:10}]}))}}if(p)for(let r=p;r;)m.push({key:r.key,color:"PATH"}),r.through&&m.push({key:r.through,color:"PATH",type:"ARC"}),r=r.predecessor;return m}}class AStar{constructor(c){this._graph=new GraphController(c)}search(c,d=c,e,j=0){let k=this._graph.at(c),l={},m=[{key:k.key,f:0,g:0}],n={},o,p=[];for(;m.length;){let r=m.reduce((t,w,y)=>{return w.f<t.f?_extends({},w,{i:y}):t},{f:Infinity,i:-1});if(-1===r.i)break;if(r.key===d){o=r;break}p.push({key:r.key,color:"EXPLORED"}),m.splice(r.i,1);for(let t of this._graph.getAdjacent(r,j,e)){const{through:w,value:y}=t[1];t=t[0];const z=e?this._graph.getDistance(t.key,d):t.h||0,A=y+r.g,B=z+A;console.log(B,A,z);const C=n[t.key];if(!C||C&&C.f>B){const D=l[t.key];(!D||D&&D.f>B)&&(m.push({key:t.key,f:B,g:A,predecessor:r,through:w}),l[t.key]={key:t.key,f:B,g:A,predecessor:r,through:w},p.push({key:t.key,color:"VISITED",text:[{text:B,offsetX:0,offsetY:2},{text:z,offsetX:0,offsetY:10},{text:A,offsetX:6,offsetY:10}]}))}}if(o)break;n[r.key]=r}if(o)for(let r=o;r;)p.push({key:r.key,color:"PATH"}),r.through&&p.push({key:r.through,color:"PATH",type:"ARC"}),r=r.predecessor;return p}}self.onmessage=({data:[c,{node:j,arc:k,start:l,end:m},d,e=0]})=>{Object.keys(j).length||self.postMessage([]);let n="dfs"===c?new DepthFirstSearch({node:j,arc:k}):"a-star"===c?new AStar({node:j,arc:k}):"dijkstras"===c?new Dijkstras({node:j,arc:k}):new BreadthFirstSearch({node:j,arc:k});j[l]===void 0&&(l=Object.keys(j)[0]),j[m]===void 0&&(m=Object.keys(j)[Object.keys(j).length-1]);const o=n.search(l,m,d,e);self.postMessage(o)};
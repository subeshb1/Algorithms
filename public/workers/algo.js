class List { constructor(arr) { try { if (arguments.length === 0) this._list = []; else this.list = arr; } catch (e) { throw e; } } get list() { return [...this._list]; } set list(arr) { console.log(); if (arr instanceof Array) { this._list = [...arr]; } else throw new TypeError("Invalid Argument type. Array or No Args Expected."); } swap(i, j) { let length = this.list.length; if (i >= length || j >= length) throw new TypeError("The values passed don't lie within the list length"); let temp = this._list[i]; this._list[i] = this._list[j]; this._list[j] = temp; } at(index) { let length = this.list.length; if (index >= length) return undefined; return this._list[index]; } storeAt(index, val) { this._list[index] = val; } } class QuickSort { constructor(list) { this._list = new List([...list]); } sort(compare) { let length = this._list.list.length; this.compare = compare; this.action = []; this.quickSort(0, length - 1); return this.action; } quickSort(p, r) { if (p < r) { let q = this.partition(p, r); this.quickSort(p, q - 1); this.quickSort(q + 1, r); } } partition(p, r) { let x = this._list.at(r); let i = p - 1; for (let j = p; j < r; j++) { if (this.compare(x, this._list.at(j))) { i++; this._list.swap(i, j); this.action.push({ type: "LIST_SWAP", payload: { pos: [i, j], boundary: [p, r], pivot: i } }); } } i++; this.action.push({ type: "LIST_SWAP", payload: { pos: [i, r], boundary: [p, r], pivot: i } }); this._list.swap(i, r); return i; } } class MergeSort { constructor(list) { this._list = new List([...list]); } sort(value) { let length = this._list.list.length; this.value = value; this.action = []; this.mergeSort(0, length - 1); return this.action; } mergeSort(p, r) { if (p < r) { let q = parseInt((p + r) / 2, 10); this.mergeSort(p, q); this.mergeSort(q + 1, r); this.merge(p, q, r); } } merge(p, q, r) { let n1 = q - p + 1; let n2 = r - q; let L = []; let R = []; for (let i = 0; i < n1; i++) { L[i] = { item: this._list.at(p + i), val: this.value(this._list.at(p + i)) }; } for (let j = 0; j < n2; j++) { R[j] = { item: this._list.at(q + j + 1), val: this.value(this._list.at(q + j + 1)) }; } L[n1] = { val: Infinity }; R[n2] = { val: Infinity }; let i = 0; let j = 0; for (let k = p; k <= r; k++) { if (L[i].val <= R[j].val) { this.action.push({ type: "LIST_STORE", payload: { i: k, val: L[i].item, boundary: [p, r], pivot: k } }); this._list.storeAt(k, L[i].item); i++; } else { this.action.push({ type: "LIST_STORE", payload: { i: k, val: R[j].item, boundary: [p, r], pivot: k } }); this._list.storeAt(k, R[j].item); j++; } } } } class HeapSort { constructor(list) { this._list = new List([...list]); this.action = []; } sort(value) { this.value = value; this.length = this._list.list.length; this.heapSize = this.length; this.buildMaxHeap(); for (let i = this.length - 1; i >= 1; i--) { this.heapExtractMax(); } return this.action; } buildMaxHeap() { for (let i = parseInt(this.length / 2, 10) - 1; i >= 0; i--) this.maxHeapify(i); } maxHeapify(i) { let l = 2 * i + 1; let r = 2 * i + 2; let largest = i; if ( l < this.heapSize && this.value(this._list.at(l)) > this.value(this._list.at(largest)) ) { largest = l; } if ( r < this.heapSize && this.value(this._list.at(r)) > this.value(this._list.at(largest)) ) { largest = r; } if (largest !== i) { this.action.push({ type: "LIST_SWAP", payload: { pos: [i, largest] } }); this._list.swap(i, largest); this.maxHeapify(largest); } } heapExtractMax() { if (this.heapSize < 1) throw new TypeError("Heap empty"); let max = this._list.at(0); this.action.push({ type: "LIST_SWAP", payload: { pos: [0, this.heapSize - 1] } }); this._list.swap(0, this.heapSize - 1); this.heapSize--; this.maxHeapify(0); return max; } } class BubbleSort { constructor(list) { this._list = new List([...list]); } sort(compare) { let length = this._list.list.length; let action = []; for (let i = length - 1; i > 0; i--) { for (let j = 0; j < i; j++) { if (compare(this._list.at(j), this._list.at(j + 1))) { this._list.swap(j, j + 1); action.push({ type: "LIST_SWAP", payload: { pos: [j, j + 1] } }); } } } return action; } } class SelectionSort { constructor(list) { this._list = new List([...list]); } sort(compare) { let length = this._list.list.length; let action = []; for (let i = 0; i < length; i++) { for (let j = i + 1; j < length; j++) { if (compare(this._list.at(i), this._list.at(j))) { this._list.swap(i, j); action.push({ type: "LIST_SWAP", payload: { pos: [i, j] } }); } } } return action; } } self.onmessage = e => { let algo; let cmp; switch (e.data[0]) { case "selection-sort": algo = new SelectionSort(e.data[1]); cmp = (a, b) => a.height > b.height; break; case "quick-sort": algo = new QuickSort(e.data[1]); cmp = (a, b) => a.height > b.height; break; case "merge-sort": algo = new MergeSort(e.data[1]); cmp = a => a.height; break; case "heap-sort": algo = new HeapSort(e.data[1]); cmp = a => a.height; break; default: algo = new BubbleSort(e.data[1]); cmp = (a, b) => a.height > b.height; break; } self.postMessage(algo.sort(cmp)); };
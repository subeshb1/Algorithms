class List{constructor(c){try{0===arguments.length?this._list=[]:this.list=c}catch(d){throw d}}get list(){return this._list}set list(c){if(console.log(),c instanceof Array)this._list=c;else throw new TypeError("Invalid Argument type. Array or No Args Expected.")}swap(c,d){let f=this.list.length;if(c>=f||d>=f)throw new TypeError("The values passed don't lie within the list length");let g=this._list[c];this._list[c]=this._list[d],this._list[d]=g}at(c){let d=this.list.length;return c>=d?void 0:this._list[c]}storeAt(c,d){this._list[c]=d}}class QuickSort{constructor(c){this._list=new List(c)}sort(c){let d=this._list.list.length;return this.compare=c,this.action=[],this.quickSort(0,d-1),this.action}quickSort(c,d){if(c<d){let f=this.partition(c,d);this.quickSort(c,f-1),this.quickSort(f+1,d)}}partition(c,d){let f=this._list.at(d),g=c-1;for(let h=c;h<d;h++)this.compare(f,this._list.at(h))&&(g++,this._list.swap(g,h),this.action.push({type:"LIST_SWAP",payload:{pos:[g,h],boundary:[c,d],pivot:g}}));return g++,this.action.push({type:"LIST_SWAP",payload:{pos:[g,d],boundary:[c,d],pivot:g}}),this._list.swap(g,d),g}}class MergeSort{constructor(c){this._list=new List(c)}sort(c){let d=this._list.list.length;return this.value=c,this.action=[],this.mergeSort(0,d-1),this.action}mergeSort(c,d){if(c<d){let f=parseInt((c+d)/2,10);this.mergeSort(c,f),this.mergeSort(f+1,d),this.merge(c,f,d)}}merge(c,d,f){let g=d-c+1,h=f-d,m=[],n=[];for(let t=0;t<g;t++)m[t]={item:this._list.at(c+t),val:this.value(this._list.at(c+t))};for(let t=0;t<h;t++)n[t]={item:this._list.at(d+t+1),val:this.value(this._list.at(d+t+1))};m[g]={val:Infinity},n[h]={val:Infinity};let o=0,s=0;for(let t=c;t<=f;t++)m[o].val<=n[s].val?(this.action.push({type:"LIST_STORE",payload:{i:t,val:m[o].item,boundary:[c,f],pivot:t}}),this._list.storeAt(t,m[o].item),o++):(this.action.push({type:"LIST_STORE",payload:{i:t,val:n[s].item,boundary:[c,f],pivot:t}}),this._list.storeAt(t,n[s].item),s++)}}class HeapSort{constructor(c){this._list=new List(c),this.action=[]}sort(c){this.value=c,this.length=this._list.list.length,this.heapSize=this.length,this.buildMaxHeap();for(let d=this.length-1;1<=d;d--)this.heapExtractMax();return this.action}buildMaxHeap(){for(let c=parseInt(this.length/2,10)-1;0<=c;c--)this.maxHeapify(c)}maxHeapify(c){let d=2*c+1,f=2*c+2,g=c;d<this.heapSize&&this.value(this._list.at(d))>this.value(this._list.at(g))&&(g=d),f<this.heapSize&&this.value(this._list.at(f))>this.value(this._list.at(g))&&(g=f),g!==c&&(this.action.push({type:"LIST_SWAP",payload:{pos:[c,g]}}),this._list.swap(c,g),this.maxHeapify(g))}heapExtractMax(){if(1>this.heapSize)throw new TypeError("Heap empty");let c=this._list.at(0);return this.action.push({type:"LIST_SWAP",payload:{pos:[0,this.heapSize-1]}}),this._list.swap(0,this.heapSize-1),this.heapSize--,this.maxHeapify(0),c}}class BubbleSort{constructor(c){this._list=new List(c)}sort(c){let d=this._list.list.length,f=[];for(let g=d-1;0<g;g--)for(let h=0;h<g;h++)c(this._list.at(h),this._list.at(h+1))&&(this._list.swap(h,h+1),f.push({type:"LIST_SWAP",payload:{pos:[h,h+1]}}));return f}}class SelectionSort{constructor(c){this._list=new List(c)}sort(c){let d=this._list.list.length,f=[];for(let g=0;g<d;g++)for(let h=g+1;h<d;h++)c(this._list.at(g),this._list.at(h))&&(this._list.swap(g,h),f.push({type:"LIST_SWAP",payload:{pos:[g,h]}}));return f}}self.onmessage=c=>{let d,f;switch(c.data[0]){case"selection-sort":d=new SelectionSort(c.data[1]),f=(h,m)=>h.height>m.height;break;case"quick-sort":d=new QuickSort(c.data[1]),f=(h,m)=>h.height>m.height;break;case"merge-sort":d=new MergeSort(c.data[1]),f=h=>h.height;break;case"heap-sort":d=new HeapSort(c.data[1]),f=h=>h.height;break;default:d=new BubbleSort(c.data[1]),f=(h,m)=>h.height>m.height;}const g=d.sort(f);self.postMessage(g)};